### ACK消息应答

#### 问题
在实际应用中,可能会发生消费者收到Queue中的消息,但没有处理完成就宕机(或出现其他意外)的情况,这种情况下就可能会导致消息丢失.  

#### 应对机制
1. 消费者在消费完消息后发送一个回执给RabbitMQ,RabbitMQ收到消息回执(Message acknowledgment)后才将该消息从Queue中移除.
2. 如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开,则RabbitMQ会将该消息发送给其他消费者(如果存在多个消费者)进行处理.
3. 这里不存在timeout概念,一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者,除非它的RabbitMQ连接断开.
4. 这里会产生另外一个问题,如果我们的开发人员在处理完业务逻辑后,忘记发送回执给RabbitMQ,这将会导致严重的bug——Queue中堆积的消息会越来越多,消费者重启后会重复消费这些消息并重复执行业务逻辑.

#### value 
1. true   处理完成之后返回确认消息
2. false  纯粹的返回说已经接受到消息

#### work queue 举例
消费者A 处理任务耗时5s  
消费者B 处理任务耗时10s  在消费第3条数据的时候关闭程序
结果:由于消费者B在消费第3条数据的时候关闭了,因此没有给rabbitmq消息应答,此时rabbitmq会把这条消息给另一个消费者A处理.
```
2018-02-08 22:38:45.068 |-INFO  [pool-2-thread-4] Receiver [56] -| hello:1处理完成--消费者A
2018-02-08 22:38:50.085 |-INFO  [pool-2-thread-4] Receiver [56] -| hello:3处理完成--消费者A
2018-02-08 22:38:55.086 |-INFO  [pool-2-thread-4] Receiver [56] -| hello:5处理完成--消费者A
2018-02-08 22:39:00.088 |-INFO  [pool-2-thread-4] Receiver [56] -| hello:7处理完成--消费者A
2018-02-08 22:39:05.089 |-INFO  [pool-2-thread-4] Receiver [56] -| hello:9处理完成--消费者A
2018-02-08 22:39:10.092 |-INFO  [pool-2-thread-5] Receiver [56] -| hello:6处理完成--消费者A
2018-02-08 22:39:15.095 |-INFO  [pool-2-thread-5] Receiver [56] -| hello:8处理完成--消费者A
2018-02-08 22:39:20.096 |-INFO  [pool-2-thread-5] Receiver [56] -| hello:10处理完成--消费者A
-----------------------------------------------------------------------------------------------------------------
2018-02-08 22:38:50.089 |-INFO  [pool-2-thread-4] Receiver [56] -| hello:2处理完成--消费者B
2018-02-08 22:39:00.107 |-INFO  [pool-2-thread-5] Receiver [56] -| hello:4处理完成--消费者B
```