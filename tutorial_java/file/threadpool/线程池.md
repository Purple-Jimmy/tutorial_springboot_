## 队列
先进先出,后进后出

## 并发队列  阻塞式队列和非阻塞式队列

## 线程池中底层使用阻塞式队列BlockingQueue



## 阻塞与非阻塞的区别

生产者-----------队列容器--------------消费者

假设队列容器最大容量为10,此时第11个队列进来
非租塞队列,如果存放超出队列容量,将会丢失信息
阻塞队列将会等待,等待的时间(根据队列设置超时时间)

获取队列
非阻塞式队列,如果为空,返回null值
阻塞式队列,如果为空,将会等待


## BlockingQueue 阻塞式队列

## ConcurrentLinkedDeque 非阻塞式队列 适用于高并发场景 无锁方式
基于链接节点的无界线程安全队列,遵循先进先出原则,头是最先加入的,队列不允许null元素
重要方法:
add()和offer():加入元素,无任何区别
poll()和peek():取头元素,poll会删除元素,peek不会


## 有界与无界
无界:可以无限循环
有界:有限的容量


## 线程池---进行统一分配,调优
1. 降低资源消耗---重复利用机制,降低创建线程和销毁线程的资源
2. 提高响应效率---当任务到达时,任务可以不需要等到线程创建就立即执行
3. 方便管理---线程时稀缺资源,如果无限的创建,会消耗系统资源,降低系统稳定性

## 原理
重复利用机制使用BlockingQueue阻塞式队列存放线程
都是对ThreadPoolExecutor的封装

## 核心参数
corePoolSize:核心线程数  实际运行线程
maximumPoolSize:最大线程数 最多可以创建多少个线程
keepAliveTime:非核心线程数闲置线程最大存活时间


